---
title: "笔记：使用 redis 实现消息队列的几种常见做法"
meta_title: ""
description: "本文讲述了如何使用 redis 实现消息队列。"
date: 2023-12-29T04:44:00+08:00
categories: ["redis"]
author: "Akaishi Toshiya"
tags: ["redis", "消息队列"]
draft: false
---

> 算是一篇观看[🎞️动画学Redis消息队列，List，发布订阅，Stream实现...](https://www.bilibili.com/video/BV14t421j7Mb)
时写的笔记，如果希望学习的话，可以去原视频看看，这里只是记录了一些要点，以备后期查看之用。

## 常见的几种实现方式

* List: 最简单的消息队列实现方式，使用内置的 `LIST` 类型实现，不支持分组。
* Sub/Pub: 基于 redisson 实现，只支持实时消息传送的场合，不缓存消息。
* Stream: 

### List

最简单的消息队列实现方式，使用 `LIST` 类型，`LPUSH` 和 `RPOP` 来实现消息队列。

**缺陷**：因为好实现，所以不支持分组，适用于多个客户端独立地去竞争消费的场合。

#### 改进1: 使用 BRPOP

上述实现中，在队列空闲时，需要循环地轮询服务器是否可以 `RPOP` 消息。使得空闲时间客户端的 CPU 时间被大幅度浪费。

所以我们可以改用 `BRPOP` 来取代 `RPOP`。
这样，在服务器的LIST中没有消息时，不会立刻返回 `nil`，而是一直阻塞，需要等到队列中有数据了，才会返回。

#### 相关命令

假设下面我们使用的队列名称叫作 `test_queue`。

```shell
# 生产者：插入消息
# 返回值：PUSH 之后 LIST 的元素总数 (integer)
LPUSH test_queue msg1

# 消费者：接受消息
# 返回值：1) 队列名  2) 出队消息
BRPOP test_queue
```

### 发布订阅

消费者可以基于 redisson 发布若干个频道，消费者订阅这些频道。
消费者在生产消息写入队列之后，消息的副本会被复制成若干份发送给订阅了相关频道的消费者。

可以看出来，这些消息都是即时的，如果中途一旦消费者掉线，就会损失中间的消息。

#### 相关命令

假设下面我们使用的队列名称叫作 `test_queue`。

```shell
# 消费者：订阅频道
# 返回值：1) "message"  2) 队列名  3) 消息
SUBSCRIBE test_queue

# 生产者：发布消息
# 返回值为收到消息的客户端的个数 (integer)
PUBLISH test_queue msg1
```

### Stream

Stream 类型是自 redis 5.0 引入的类型，支持消费者组。

组的概念：不同的消费组订阅同一个 stream 时，所有的消费组都会收到消息的副本。
每个组内可以有多个消费者，当消息到达消费组时，组内的消费者会竞争地去获取这个消息。

#### 可靠性

stream 支持消息确认，每个消息有一个序列号，格式大概是 `时间戳-序号`，例：`1713528164309-0`。
这个 ID 用于维持消息的顺序。可自定，但是需要保持格式一直。

当创建消费者组时，每个组内会自动地维护两个字段：

* `LastDeliveredID`： 最后一个被读取的消息的 ID。
* `PendingList`： 已被读取，但是还没有被 `ack` 的消息列表。

-----

* 当一个消息到达消费组时，会更新 `LastDeliveredID` 为该消息的 ID，并且将这个 ID 加入到 `PendingList` 中。
* 当消费者发送 `ack` 时，从 `PendingList` 中移除这个 ID。
* 我们可以通过启动一个补偿服务，定时地去访问 `PendingList`，检查是否有长时间积压的消息，可以单独处理并 `ack`。
* 当同一条消息被重复 `ack` 时，在 `redis` 中不会有什么问题。但是在客户端需要保证每次操作的幂等性。

